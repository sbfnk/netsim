#ifndef SIMULATOR_HH
#define SIMULATOR_HH

#include "Model.hh"

class Simulator
{

public:
      
  Simulator(const Model& m, unsigned int v = 0) :
    model(m), verbose(v), time(0.), numInfections(0),
    numInformations(0), numRecoveries(0), numForgettings(0) {}

  virtual ~Simulator() {;}
      
  virtual void initialize() {;}
  
  virtual bool updateState() = 0;

  virtual void print() {;}

  double getTime() const { return time; };
  void updateTime(double t) { time += t; };

  unsigned int getNumInfections() const { return numInfections; }
  unsigned int getNumRecoveries() const { return numRecoveries; }
  unsigned int getNumInformations() const { return numInformations; }
  unsigned int getNumForgettings() const { return numForgettings; }

  void addInfection() { ++numInfections; }
  void addInformation() { ++numInformations; }
  void addRecovery() { ++numRecoveries; }
  void addForgetting() { ++numForgettings; }

protected:
  
  const Model& model;
  unsigned int verbose;

private:

  double time;
  unsigned int numInfections;
  unsigned int numInformations;
  unsigned int numRecoveries;
  unsigned int numForgettings;
      
};


/******************************************************************/
// generateEventList function
// generates an event list for a given vertex in a given graph,
// using a given model. The vertices of the event must be of type
// Vertex, otherwise this will throw a compile error
/******************************************************************/
template <class Graph, class Model>
double generateEventList(Graph& graph,
                         typename boost::graph_traits<Graph>::vertex_descriptor v,
                         const Model& model,
                         unsigned int verbose = 0)
{
  // definitions of boost types for quick access
  typedef typename boost::graph_traits<Graph>::out_edge_iterator
    out_edge_iterator;
  typedef typename boost::graph_traits<Graph>::edge_descriptor
    edge_descriptor;
  typedef typename boost::graph_traits<Graph>::vertex_descriptor
    vertex_descriptor;

  typename boost::property_map<Graph, boost::vertex_index_t>::type 
    id = get(boost::vertex_index, graph);
   
  // temporary sum for the new sum of rates of all events
  // that can affect the vertex v
  double tempSum = .0;

  if (verbose >= 2) {
    std::cout << "Generating events list for vertex #" << v << " ("
              << model.getVertexStates()[graph[v].state] << ")" << std::endl;
  }

  // clear event list
  graph[v].events.clear();
   
  // get node events
  tempSum += model.getNodeEvents(graph[v].events, graph[v].state, id[v]);
   
  // get edge events
  out_edge_iterator oi, oi_end;;
   
  for (tie(oi, oi_end) = boost::out_edges(v, graph);
       oi != oi_end; ++oi) {
    edge_descriptor e = *oi;
    vertex_descriptor t =  target(e, graph);
    tempSum +=
      model.getEdgeEvents(graph[v].events, graph[v].state,
                          graph[e].type, graph[t].state, id[t]);
     
  }
   
  // calculate difference between new and old sum of rates
  double diff = tempSum - graph[v].rateSum;
  // set rateSum to new value
  graph[v].rateSum = tempSum;
   
   
  return diff;
}

/******************************************************************/
// updateEventList function
// updates the event list generated by the source of edge e for the
// target of edge e
/******************************************************************/
template <class Graph, class Model>
double updateEventList(Graph& graph,
                       typename boost::graph_traits<Graph>::edge_descriptor e,
                       const Model& model,
                       unsigned int verbose = 0)
{
  typename boost::graph_traits<Graph>::vertex_descriptor v = target(e, graph);
  typename boost::graph_traits<Graph>::vertex_descriptor n = source(e, graph);
  
  typename boost::property_map<Graph, boost::vertex_index_t>::type 
    id = get(boost::vertex_index, graph);
   
  // temporary sum for the new sum of rates of all events
  // that can affect the vertex v
  double tempSum = .0;

  if (verbose >= 2) {
    std::cout << "Updating events list for vertex #" << v << " ("
              << model.getVertexStates()[graph[v].state] << ")"
              << ", as generated by neighbour #" << n << " ("
              << model.getVertexStates()[graph[n].state] << ") along "
              << model.getEdgeTypes()[graph[e].type] << "-edge" << std::endl;
  }
  for (unsigned int i = 0; i < graph[v].events.size(); i++) {
    if (graph[v].events[i].nb == id[n] &&
        graph[v].events[i].et == graph[e].type) {
      tempSum -= graph[v].events[i].rate;
      graph[v].events.erase(graph[v].events.begin() + i);
      --i;
    }
  }

  tempSum +=
    model.getEdgeEvents(graph[v].events, graph[v].state,
                        graph[e].type, graph[n].state, id[n]);
  
  // update rateSum
  graph[v].rateSum += tempSum;
    
  return tempSum;
}

#endif
